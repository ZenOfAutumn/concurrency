# 线程安全性


### 基本概念
### 修复多线程访问未同步的可变状态变量的三种：

- 不在线程之间共享该变量
- 该状态变量修改为不可变的变量
- 在访问状态变量时使用同步

### 线程安全性：
- 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

### 无状态的类：
- 既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。
- 无状态的类一定是线程安全的。

### 竞态条件（Race Condition）:
- 由于执行时序而出现不正确的结果。

### 原子操作：
- 对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。

### 不变性条件：
- 线程安全性的定义中要求，多个线程之间无论采取何种执行时序或交替方式，都要保证不变性条件不被破坏。当在不变性条件中涉及多个策略时，各个变量之间不是彼此独立的话，某个变量的值就会对其他变量的值产生约束。要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

### 内置锁：
- synchronized同步代码块：
  1. 指定同步对象引用
    ```java
     synchronized(lock){}
    ```

  2. synchronized修饰的对象中非静态方法,以该对象实例作为锁：
     ```java
     public void synchronized foo(){}
     ```

  3. synchronized修饰的对象中静态方法,以class对象作为锁：
    ```java
    public static void synchronized foo(){}
    ```

### 重入：
-  当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会被阻塞。而如果这个线程试图获取已经由它自己持有的锁，则这个请求就会成功。否则，就会导致死锁的发生。
-  重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程所持有，当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1，如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。

### 用锁来保护状态：
- 仅仅将复合操作封装到一个同步代码块中是不够的。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要同步。
- 当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。
- 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况，我们称状态变量是由这个锁来保护的。
- 每个共享的和可变的变量都应该只有一个锁来保护，从而使维护人员知道是哪一个锁。 
- 一种加锁的约定是：使所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得该对象上不会发生并发访问。
- 当类的不变性涉及到多个状态变量时，在不变性条件中的每个变量都必须由同一个锁来保护。

### 活跃性与性能：
- 要确保同步代码块不要过小，且不要将本应是原子的操作拆分到多个同步代码中。应尽量将不影响共享状态且执行时间较长的操作从同步代码中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。
- 要判断同步代码的合理大小，需要在各个设计需求之间进行权衡，包括安全性、简单性和性能。通常在简单性和性能之间存在着相互制约，不要盲目地为了性能而牺牲简单性。当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。



