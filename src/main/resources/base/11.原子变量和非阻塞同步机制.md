
# 原子变量和非阻塞同步机制

## 锁的劣势

- 挂起和恢复线程等过程中存在着巨大的开销，并且通常存在着较长时间的中断。
- 如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。
- 锁定方式对于细粒度的操作来时仍然是一种高开销的机制。

## CAS

- Compare and Swap，比较并操作，CPU指令，在大多数处理器架构，包括IA32、Space中采用的都是CAS指令，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

- 独占锁是悲观锁，CAS是乐观锁。

- 典型使用模式：首先从V中读取值A，并根据A计算新值B，然后再通过CAS以原子方式将V中的值从A编程B。


//  ToDo JVM中CAS


## 原子变量类

### 原子更新基本类型

AtomicBoolean：原子更新布尔类型。

AtomicInteger：原子更新整型。

AtomicLong：原子更新长整型。

###  原子更新数组类型

AtomicIntegerArray：原子更新整型数组里的元素。

AtomicLongArray：原子更新长整型数组里的元素。

AtomicReferenceArray：原子更新引用类型数组里的元素。

### 原子更新引用类型

AtomicReference：原子更新引用类型。

AtomicReferenceFieldUpdater：原子更新引用类型里的字段。

AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类
型的标记位和引用类型。

AtomicStampedReference：原子更新带有版本号的引用类型。使用一个版本号表示当前数据版本，避免ABA问题。



### 原子更新字段类型

AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。

AtomicLongFieldUpdater：原子更新长整型字段的更新器。

- 要想原子地更新字段类需要两步。
	1. 用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。
	2. 更新类的字段（属性）必须使用public volatile修饰符。

### 性能比较

- 在高度竞争的情况下，锁的性能将超过原子变量的性能，但一般真实竞争情况下，原子变量的性能要优于锁的性能。



## 多状态值一致性CAS

- 在并发链表中，存在需要原子更新多个状态值的步骤，例如：在插入链表节点时，尾节点指针和当前尾节点的next指针都要CAS为新插入的尾节点。

- 第一个技巧是，即使在一个包含多个步骤的更新操作中，也要确保数据结构总是处于一致的状态。这样，当线程B到达时，如果发现线程A正在执行更新，那么线程B就可以知道有一个操作已部分完成，并且不能立即开始执行自己的更新操作。然后，B可以等待（通过反复检查队列的状态）并直到A完成更新，从而使两个线程不会相互干扰。


- 第二个技巧是，如果当B到达时发现A正在修改数据结构，那么在数据结构中应该有足够多的信息，使得B能完成A的更新操作。如果B“帮助”A完成了更新操作，那么B可以执行自己的操作，而不用等到A的操作完成。当A恢复后再试图完成其操作时，会发现B已经替它完成了。


