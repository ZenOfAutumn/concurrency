
# 性能与可伸缩性

## 概念

- 1. 性能指标：服务时间、延迟时间、吞吐率、效率、可伸缩性、容量。
- 2. 可伸缩性：当增加计算资源（CPU、内存、存储容量、I/O带宽），程序的吞吐量或处理能力相应地增加。

## Amdahl定律

### 定义
- 在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于可并行组件与串行组件所占的比重。假定F是必须被串行执行的部分，那么根据Amdahl定律，在包含N个处理器的机器中，最高的加速比为：
```
Speedup <= 1 / ( F + (1-F) / N )
```
当N趋近于无穷大时，最大的加速比趋近于1/F。因此，如果程序有50%的计算需要串行执行，那么最高的加速比只能是2（而不管有多少个线程可用）。

## 线程引入的开销

### 1. 上下文切换（Context Switch）

- 操作系统的设计者巧妙地利用了时间片轮转的方式, CPU给每个任务都服务一定的时间, 然后把当前任务的状态保存下来, 在加载下一任务的状态后, 继续服务下一任务. 任务的状态保存及再加载, 这段过程就叫做上下文切换。

- 上下文切换会带来直接和间接两种因素影响程序性能的消耗。 直接消耗包括： CPU寄存器需要保存和加载, 系统调度器的代码需要执行, TLB实例需要重新加载, CPU 的pipeline需要刷掉。 间接消耗指的是多核的cache之间得共享数据, 间接消耗对于程序的影响要看线程工作区操作数据的大小。


### 2. 内存同步

- 在synchronized和volatile提供的可见性保证中可能会使用一些特殊指令，即内存栅栏（Memory Barrier）。内存栅栏可以刷新缓存，使缓存无效，刷新硬件的写缓存，以及停止执行管道。内存栅栏可能同样会对性能带来间接的影响，因为它们将抑制一些编译器优化操作。在内存栅栏中，大多数操作都是不能被重排序的。

### 3. 阻塞

- 非竞争的同步可以完全在JVM中进行处理，而竞争的同步可能需要操作系统的介入，从而增加开销。当在锁上发生竞争时，竞争失败的线程肯定会阻塞。JVM在实现阻塞行为时，可以采用自旋等待（Spin-Waiting，指通过循环不断地尝试获取锁，知道成功）或者通过操作系统挂起被阻塞的线程。这两种方式的效率高低，要取决于上下文切换的开销以及在成功获取锁之前需要等待的时间。如果等待的时间较短，则适合采用自旋等待方式，而如果等待的时间较长，则适合采用线程挂起方式。

- 当线程无法获取某个锁或者由于在某个条件等待或在I/O操作阻塞时，需要被挂起，在这个过程中将包含两次额外的上下文切换，以及所有必要的操作系统和缓存操作：被阻塞的线程在其执行时间片还未用完之前就被交换出去，而在随后当要获取的锁或者其他资源可用时，又再次被切换回来。（由于锁竞争而导致阻塞时，线程在持有锁时将存在一定的开销：当它释放锁时，必须告诉操作系统恢复运行阻塞的线程。）


## 减少锁的竞争

- 减少锁的持有时间。
- 降低锁的请求频率。
- 使用带有协调机制的独占锁，这些机制允许更高的并发性。
### 1.  缩小锁的范围

### 2.  减小锁的粒度

- 锁分解：如果一个锁需要保护多个相互独立的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量，从而提高可伸缩性，并最终降低每个锁被请求的频率。
- 锁分段：在某些情况下，可以将锁分解技术进一步扩展为对一组独立对象上的锁进行分解，这种情况被称为锁分段。

### 3. 避免热点域

- 将一些反复计算的结果缓存起来，都会引入一些"热点域"，例如每次操作都要修改的计数器。

### 4. 替代独占锁

- 使用并发容器、读写锁、不可变对象以及原子变量来替代独占锁。

### 5. 监测CPU的利用率

1. 负载不充足
2. I/O密集
3. 外部限制
4. 锁竞争

### 6. 避免对象池

- 在单线程程序中，尽管对象池技术能降低垃圾收集操作的开销，但对象高开销意外的其他对象来说，仍然存在性能缺失。除了损失CPU指令周期之外，对象池面临着一些其他的问题：
	- 1. 如何正确设定对象池的大小（太小不起作用，太大则对垃圾收集产生压力）；
	- 2. 重新使用某个对象却未将其恢复到正确的状态。
	- 3. 一个线程将对象归还对象池后仍然使用该对象的问题，导致基于代的垃圾回收器需要执行更多的工作。

- 在并发程序中，对象池的表现更加糟糕：
	- 如果这些线程从对象池中请求一个对象，那么就需要通过某种同步来协调对对象池数据结构的访问，从而可能使某个线程被阻塞。（线程分配对象在TLAB ThreadLocalAllocBuffer上分配，无需同步）。
	- 如果某个线程由于锁竞争而被阻塞，那么这种阻塞的开销将是内存分配操作开销的数百倍，因此即使对象池带来的竞争很小，也可能形成一个可伸缩性的瓶颈。（即使是一个非竞争的同步，导致的开销也会比分配一个对象的开销大。）

